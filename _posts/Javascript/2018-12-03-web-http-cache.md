---
layout: post
title: HTTP 캐시 (웹캐시)
category: Javascript
permalink: /Javascript/:title/

tags: [자바스크립트]
comments: true
---

![http-cache]({{site.baseurl}}/img/http-cache.png)
대용량 서비스에서 효율적인 리소스관리를 위해 주로 Cache를 사용하는데요. 이번엔 다양한 캐싱방법중 프론트단에서 가장 쉽게 사용할 수 있는 **HTTP 캐시(웹캐시)**에대해 알아보았습니다 :)

## Cache?
> (무기 등의) 은닉처. 은닉하다

- Cache : 속도를 빠르게 하기위해 데이터를 미리 복사해둔 임시 저장소.
- 컴퓨터 분야에서의 캐시는 (주로 접근 속도의 개선을 위해) 데이터를 미리 복사해 놓는 임시 저장소, 혹은 그 임시 저장소에 데이터를 저장하는 행위
- 컴퓨터의 아주 많은 부분(CPU, GPU, HDD, 네트워크, 웹, 데이터베이스...)에서 사용되고 있음

## HTTP Cache
- 자원의 효율적 로딩을 위한 웹 표준
- 서버에서 가져온 자원(HTML, CSS, JS, 이미지, ...)을 가까운 곳(브라우저, 혹은 다른 서버)에 저장해놓고 재사용
- 이전에 가져온 리소스를 캐시했다가 재활용할 수 있는 기능은 성능 최적화에 있어 중요한 측면

## 캐시의 문제

>**사이트의 실제자원과 캐시자원이 달라지는 상황**  
어떤 페이지를 방문했을때 index.html을 캐시에 저장해두고 재사용을 하는데, 홈페이지 업데이트를 하면 어떻게 해야될까?

1. **Expiration(만료): Cache-Control**
    - Response Header에 자료의 유효기간 설정
    -> 개발자의 예상과 다르게 불가피한 변경이 있으면 반영이 안됨 (netlify에선 안쓴다!)
2. **Validation(검증) : ETag(자원의 내용 식별자)**
    - 서버에 식별자(ETag)와 함께 요청을 보내서 캐시를 계속 사용할 수 있는지 확인

## 캐시관련 헤더
- **Cache-Control**  
(요청, 응답) 캐시와 관련된 다양한 기능을 하는 지시자를 포함. no-cache, max-age가 많이 사용됨. no-cache, max-age=0 지시자는 캐시를 사용하지 않도록 하거나, 캐시를 아직도 쓸 수 있는지 검증하기 위해 사용됨 (각각의 자세한 의미)
- **ETag**  
(응답) 캐시의 검증을 위해 사용되는 자원의 식별자. 주로 자원의 해시값이 사용되나, 마지막으로 수정된 시각, 혹은 버전 넘버를 사용하기도 함
- **Expires**  
(응답) 캐시를 만료시킬 시각을 서버에서 명시적으로 지정
- **Last-Modified**  
(응답) 원래 자료가 마지막으로 수정된 시각
- **If-None-Match**  
(요청) 검증을 위해 사용됨. 이전에 저장해두었던 자원의 ETag 값을 If-None-Match 헤더의 값으로 요청에 포함시켜서 보내면, 서버는 해당 경로에 있는 자원의 ETag와 비교해보고 자원의 전송 여부를 결정
- **If-Modified-Since**  
(요청) 검증을 위해 사용됨. 이전에 저장해두었던 자원의 Last-Modified 값을 If-Modified-Since 헤더의 값으로 요청에 포함시켜서 보내면, 서버는 해당 경로에 있는 자원의 Last-Modified와 비교해보고 자원의 전송 여부를 결정

## ETag로 효율적인 리소스 관리를 하자!

Q: 웹 개발자로서 어떻게 효율적으로 데이터를 관리할 수 있을까?  
A: 브라우저가 우리를 대신하여 모든 작업을 수행한다. 한 가지 남은 일은 필요한 **ETag 토큰을 서버가 제공하는지 확인하는 것뿐 !**

1. 리소스 최초 요청시, 서버는 일반적으로 파일 콘텐츠의 해시나 기타 일부 지문인 임의 토큰을 생성(ETag)하여 응답에 보낸다
![etag1]({{site.baseurl}}/img/etag1.jpg)

2. 이후 브라우저는 서버에 리소스 요청시, ETag이 이전에 캐싱해둔 리소스에 지정되었는지 자동으로 탐지하고, ETag를 요청의 [If-None-Match 헤더](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match)의 값에 보내서 저장되어있는 캐시를 계속 사용할 수 있을지 서버에 유효성검사 요청한다
3. 서버는 현재 리소스와 비교를 하고, 토큰이 변경되지 않은 경우,  `304 Not Modified` 응답을 내보내며 리소스를 다시 다운로드할 필요가 없다고 말해준다

![etag2]({{site.baseurl}}/img/etag2.jpg)

4. 즉, 리소스가 변경되지 않은 경우 데이터가 전송되지 않고, 효율적인 리소스 업데이트가 가능해진다

## ETag 생성원리
서버는 일반적으로 파일 콘텐츠의 해시나 기타 일부 지문인 임의 토큰을 생성하고 반환합니다.

`etag:W/"518-IUUcU4dNqz88Ytwacyqq9mV+V2g"`
* 원리 : 중복을 제거한다
* 자원의내용을 hash라는 알고리즘을 통해 Hashing문자열을 생성하여 etag에 달아준다.
* 내용이 .(쩜) 하나라도 달라지면 hash값이 달라진다.
* 해시생성알고리즘 : MD5, SHA-1, SHA-256 -> [SHA1 online 사이트](http://www.sha1-online.com/)

>**해시사용 예시**
>* 불법다운로드시 iso 생성해서 사용하는 경우 해시사용
>* 깃허브 commit ID, 파이어베이스 uid


