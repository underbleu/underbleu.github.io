---
layout: post
title: 3-1. map, filter 계열 함수 만들기
category: Functional-programming
permalink: /Functional-programming/:title/

tags: [함수형 프로그래밍]
comments: true
---

>프로그래머스에서 진행한 유인동님의 [ES6로 알아보는 동시성 & 함수형 프로그래밍 강의](https://programmers.co.kr/learn/courses/3409)를 들으며 정리한 내용입니다.

## baseMF 리팩토링

---

## Iterable computed data

ES6의 data-structure (Arrays, Typed Arrays, Maps, Sets)는 **well-formed 이터러블을 리턴**해주는 3가지 메서드를 가지고 있다

* `keys()` - key를 담고있는 Iterator object 리턴
* `values()` - value를 담고있는 Iterator object 리턴
* `entries()` - [key, value]를 담고있는 Iterator object 리턴
  * 배열의 경우 [index, element]
  * Set의 경우 [key, key]

```js
[][Symbol.iterator]() // Array Iterator {}
[].values() // Array Iterator {}

const arr = ['a', 'b', 'c']
const arrEntries = arr.entries()

arrEntries === arrEntries[Symbol.iterator]() 
// true --> well-formed 이터러블

arrEntries.next().value // [0, 'a']

for (const pair of arr.entries()) log(pair)
// [1, 'b'] --> Continue with same Iterator
// [2, 'c']
```

---

## # map계열 함수

## `values()`: value를 추출하는 함수

`Object.values()` 메서드에선 지원하지 못하는 Set, Map등의 값도 받을 수 있도록 다형성을 높혀보자

* `Object.values()` (ES8)
  * 객체의 enumerable 속성의 값을 배열로 리턴 
  * 내부적으로 for...in처럼 key값을 이용해 순회하기 때문에 Set, Map에 사용불가

  
### 1. 기본 - Map, Plain Object 대응이 안됨

* 기존의 `map()`함수를 이용하면 Set은 잘 동작하지만
* Map은 디폴트 `[Symbol.iterator]`로 entries를 사용하기 때문에 값만 추출되지 않고 key-value쌍으로 출력된다
* Plain Object 역시 key-value쌍으로 출력된다

```js
const values1 = coll => map(a => a, coll)

values1(new Set([1, 2, 3, 4])) // [1, 2, 3, 4]
values1(new Map([['a', 1], ['b', 2]])) // [["a", 1], ["b", 2]]
values1({a:1, b:2})) // {a: 1, b: 2}
```

```js
Map.prototype[Symbol.iterator] // ƒ entries() { ... }
Set.prototype[Symbol.iterator] // ƒ values() { ... }
```

### 2. Map 대응

Map이 들어오면 `[Symbol.iterator]`로 values를 사용하도록 설정

```js
const values2 = coll =>
  coll instanceof Map ?
    map(a => a, coll.values()) :
    map(a => a, coll);

values2(new Map([['a', 1], ['b', 2]])) // [1, 2]
```

### 3. Plain Object 대응

Map이외의 값은 collIter를 통과시켜 valuesIter로 값만 추출될 수 있도록 한다

```js
const collIter = coll =>
  hasIter(coll) ? coll[Symbol.iterator]() : valuesIter(coll)
  
const values3 = coll =>
  coll instanceof Map ?
    map(a => a, coll.values()) :
    map(a => a, collIter(coll));

values3({ a: 1, b: 2 }) // [1, 2]
```

### 4. 완성
`values()`는 단순히 값을 추출하는 역할을 넘어, **값을 평가하는 확장성**까지 있는 함수이다

```js
const values = coll =>
  map(identity, coll instanceof Map ? coll.values() : collIter(coll))

values(function *() {
  yield 1;
  yield 2;
  yield 3;
} ())
// [1, 2, 3] -> 값을 평가하는 확장성
```

## `entries()`: [key, value]를 추출하는 함수

```js
var entries = coll =>
  map(identity, hasIter(coll) ? coll.entries() : entriesIter(coll))

entries(new Set(['a', 'b'])) 
// [['a', 'a'], ['b', 'b']]
entries(new Map([['a', 1], ['b', 2]])) 
// [['a', 1], ['b', 2]]
```

---

## # filter계열 함수

```js
const entries = coll => {
  // hasIter(coll) ? coll.entries() : entriesIter(coll);
  return map(a => a, hasIter(coll) ? coll.entries() : entriesIter(coll))
}

console.log( entries([1, 2]) );
// [[0, 1], [1, 2]]
console.log( entries({ a: 1, b: 2 }) );
// [["a", 1], ["b", 2]]
console.log( entries(new Map([['a', 1], ['b', 2]])) );
// [["a", 1], ["b", 2]]
```
