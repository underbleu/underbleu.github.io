---
layout: post
title: 2-7. 컬렉션 중심 프로그래밍 - filter의 다형성 높이기, map과 filter 리팩토링, gen 함수
category: Functional-programming
permalink: /Functional-programming/:title/

tags: [함수형 프로그래밍]
comments: true
---

>프로그래머스에서 진행한 유인동님의 [ES6로 알아보는 동시성 & 함수형 프로그래밍 강의](https://programmers.co.kr/learn/courses/3409)를 들으며 정리한 내용입니다.


## for...of 중단 문제

## `collIter()` 리팩토링
* 문제의 보다 직접적인 원인을 찾기위해  
-> coll이 Plain Object인지를 보기 보단, `[Symbol.iterator]`가 구현되어있는지를 판별기준으로 보자
```js
console.log( map8(a => a + 100, {a: 1, b: 2, c: 3, d: 4}) ); //{a: 101, b: 102, c: 103, d: 104}
map8(a => Promise.resolve(a + 100), {a: 1, b: 2, c: 3, d: 4}).then(console.log); //{a: 101} --> 오작동
```
-> 여전히 비동기코드에서는 for...of가 1번 동작하고 종료되어 버리는 현상을 볼 수 있다  
-> 문제는 제너레이터로 만든 이터러블 객체이다

>[return() terminates the generator](http://exploringjs.com/es6/ch_generators.html#_return-terminates-the-generator)  
>close iterators: return() performs a return at the location of the yield that led to the last suspension of the generator.

## `gen()`: 제너레이터를 위임해주는 래퍼함수
* 제너레이터들을 `gen()`으로 감싸준다



## `reduce, filter` 리팩토링
`collIter()`를 리팩토링할때처럼, `coll`을 판단하는 기준을 "Plain Object인지 -> `[Symbol.iterator]`가 구현되있는지"로 보도록

```js
const map8 = (f, coll) =>
  coll[Symbol.iterator] ?
    reduce5(
      (res, a) => then2(f(a), b => push(res, b)), 
      coll, 
      []) :
      reduce5(
      (res, [k, a]) => then2(f(a), b => set(res, k, b)),
      entriesIter(coll),
      {}) ;


const filter5 = (f, coll) => 
  coll[Symbol.iterator] ? 
    reduce5(
      (res, a) => then2(f(a), b => b ? push(res, a) : res), 
      coll, 
      []) :
      reduce5(
      (res, [k, a]) => then2(f(a), b => b ? set(res, k, a) : res),
      entriesIter(coll),
      {}) ;
```

## `hasIter()`
함수들의 이터레이터 있는지 여부를 체크해주는 중복코드 제거  
-> 코드가 간결해질뿐만아니라, 의미가 명확해져 가독성도 좋아진다
```js
const hasIter = coll => !!(coll[Symbol.iterator]);
```

## `baseMF()`: map, filter를 만들 베이스함수
f1, f2: map을 만들기위한 보조함수(구조)
f: 사용자가 전달한 함수. 무엇으로 mapping, filter 할것인지 조건함수


아래 코드가 왜 이렇게 돌아가는지 정확히 알았습니다.

for...of 는 내부적으로 for of 가 종료된 후에 받아둔 iterator에 .return() 이 구현되어있다면 .return() 을 실행하도록 되어있네요. 그래서 return으로 for...of를 빠져나가면 .return()을 실행하므로 그렇게 됩니다. 근데 여기서 비동기가 안일어나면 .return()이 실행되기전에 재귀가 먼저 종료되므로 문제가 안생기고 비동기가 일어나면 .return()이 먼저 실행되어, iter.next()가 { done: true }가 되도록 되어있어 더이상 for...of로 순회가 불가능합니다.

그래서 제너레이터로 만든 결과를 return()이 없는 객체로 감싸서 위임하도록 하거나, 파격적으로 .return에 null을 대입해버리는 방법이 있습니다.

조현우님께서 보내주신 for of를 es5로 구현한 코드를 보고 알게 되었습니다. 


에러가 발생했을때 이터레이터를 종료시켜서 제너레이터 객체 자체를 언능 날려버릴 수 있게 하기 위한 목적


---
# 문제 해결 삽질 ! (푸걱)

## 보조함수가 프로미스일때, coll에 Promise.resolve(obj)를 받지 못하는 문제

```js
reduce6(
  (a, b) => Promise.resolve(a + b),
  Promise.resolve({a:1,b:2,c:3})).then(console.log) //3 --> 문제있음
  
reduce6(
  (a, b) => Promise.resolve(a + b),
  {a:1,b:2,c:3}).then(console.log) //3 --> 문제있음
  
reduce6(
  (a, b) => Promise.resolve(a + b),
  [1,2,3]).then(console.log) //6 --> 정상동작
  
reduce6(
  (a, b) => a + b,
  Promise.resolve({a:1,b:2,c:3})).then(console.log) //6--> 정상동작
```


보조함수가 프로미스이면, for문의 `acc = f(acc, v)`의 값은 프로미스이기 때문에 재귀가 일어난다. 

### 이 때, 
1. `coll`이 "배열/배열담은 Promise"일 땐, 재귀를 돌렸을때 for문이 그 자리에서 다시 진행되지만
2. `coll`이 "객체/객체담은 Promise"일 땐, 재귀를 돌렸을때 for문이 종료되어있다  
-> for루프는 종료된 상태이기 때문에 for루프를 1회밖에 순회하지 못한 acc(누적값)이 반환값이 된다

### for루프가 종료되어 있는 이유는 무엇일까?
* 배열역시 제너레이터로 만든 객체이면 오작동한다  
-> `valuesIter()` 제너레이터의 문제인 것 같다  

```js
var obj = {a:1,b:2,c:3}
var objIterG = valuesIter(obj)
objIterG // valuesIter {<suspended>}

var arr = [1,2,3]
var arrIterG = valuesIter(arr);
arrIterG // valuesIter {<suspended>}

reduce6((a, b) => Promise.resolve(a + b), arrIterG).then(console.log) 
// 3 --> 오작동
reduce6((a, b) => Promise.resolve(a + b), objIterG).then(console.log)
// 3 --> 오작동
```


---

## 해결책
>"버그인지는 모르겠는데, generator가 만든 iterator는 for of에 promise가 돌아가면 아예 끝내버린다."

### Generator의 기본동작
* 제너레이터는 제너레이터 객체를 반환한다
  * 제너레이터 객체는 for-of 루프로 순회할 수 있으며 -> 이터러블(iterable)이면서
  * next() 메소드를 가지고 있다 -> 동시에 이터레이터(iterator)이다
* 제너레이터 함수는 호출되어도 즉시 실행되지 않고, 대신 함수를 위한 Iterator 객체(일종의 pointer)가 반환한다
* Iterator의 next() 메서드를 호출하면 제너레이터 함수가 실행되어 yield문을 만날 때마다 value, done 프로퍼티를 갖는 객체를 반환한다

### Generator.prototype.return()
제너레이터의 `.return()` 메소드는 제공된 값을 반환하고 Generator를 종료시킨다
```js
var test = valuesIter([1,2,3])
test.next(); // {value: 1, done: false}
test.next(); //{value: 2, done: false}

test // valuesIter {<suspended>} --> 아직 종료되지 않은상태

test.return(); //{value: undefined, done: true} --> 종료시키기

test3 // valuesIter {<closed>} --> 종료된상태
```
* 일반 이터러블객체의 iterator에는 `.return()`메소드가 없지만
* 제너레이터로 만든 제너레이터객체의 iterator에는 `.return()`메소드가 있다

```js
var arrIter = [1,2,3][Symbol.iterator](); // Array Iterator {}
var arrIterG = valuesIter([1,2,3]); // valuesIter {<suspended>}

arrIter.next(); // {value: 1, done: false}
arrIter.return(); // TypeError -> return메소드 없음

arrIterG.next(); // {value: 1, done: false}
arrIterG.return(); // {value: undefined, done: true}
```

### Generator로 만든 이터러블과 for...of가 만났을때

>for...of는 내부적으로 루프가 종료되었을 때, 받아둔 iterator에 `.return()`메소드가 있다면 이를 실행시켜 이터러블을 종료시킨다  

`reduce()`의 보조함수로 Promise가 왔을때, 비동기가 일어나 재귀를 돌게되는데...

* 일반 이터러블의 iterator엔 `.return()`메소드가 없어 재귀를 돌기위해 루프를 빠져나가도 다시 그 자리에서 루프가 실행되지만
* 제너레이터로 만든 객체의 iterator는 재귀를 돌기위해 루프를 빠져나가는 순간, `.return()`메소드를 실행시켜 제너레이터를 종료시키므로 더이상 순회가 불가능해진다

* for...of 는 내부적으로 for of 가 종료된 후에 받아둔 iterator에 `.return()`메소드가 구현되어있다면 `.return()` 을 실행하도록 되어있다
* 그래서 acc값이 프로미스라 재귀를 돌기위해 `return acc.then(recur);` 으로 for...of를 빠져나가면, iterator의 `.return()`을 실행하므로 Generator가 종료된다


```js
//1. coll의 값으로 plain object가 오면 
//2. *valuesIter 제너레이터를 이용해 iterable 객체를 만든다
const collIter = coll => 
  coll.constructor == Object ? valuesIter(coll) : coll[Symbol.iterator]();

function reduce(f, coll, acc) { 
  return then(function () {
    var iter = collIter(coll);
    acc = acc === undefined ? iter.next().value : acc;
    return then(function recur(acc) {
      for (const a of iter) {
        acc = f(acc, a); 
        //3. 보조함수가 프로미스이기 때문에, 반환값은 프로미스 -> acc
        if(acc instanceof Promise) return acc.then(recur);
        //4. 재귀를 돌기위해 for...of를 빠져나가면
        //5. iterator의 `.return()`을 실행 -> Generator 종료
      }
      return acc; 
      //6. 더이상 제너레이터 객체 순회 불가하기 때문에, 첫 누적값이 반환
    }, acc)
  }, coll)
}

reduce((a, b) => Promise.resolve(a + b), {a: 1, b: 2, c: 3}); // 3 
```

* 비동기가 안일어나면,  
제너레이터로 만든 이터레이터를 for...of에 다시 넣어도 `.return()`이 실행되기전에 재귀가 먼저 종료되므로 문제가 안생기고
* 비동기가 일어나면,  
재귀를 돌기위해 for문을 빠져나가면서 `.return()`이 먼저 실행되어, `iter.next()`가 `{ done: true }`가 되도록 되어있어 더이상 for...of로 순회가 불가능하게된다



### 해결책

1. 제너레이터로 만든 결과를 `.return()`이 없는 객체로 감싸서 위임하도록 하거나  
2. 파격적으로 `.return`에 `null`을 대입해버리는 방법이 있다
```js
const iter = valuesIter({ a: 1, b: 2 });

//1.
function wrap(iter) {
  return { next: () => iter.next(), [Symbol.iterator]() { return this; }};
}

//2.
function delReturn(iter) {
  iter.return = null;
  return iter;
}
```

```js
// 해결책
function gen(g) {
  return function(v) {
    const iter = g(v);
    return { next: () => iter.next(), [Symbol.iterator]() { return this; } }
  }
}

const valuesIter = gen(function *(obj) {
  for (const k in obj) yield obj[k];
});
```

---


# 질문 ~.~

## Q: well-formed iterable이 가지는 장점이 있을까요 ?
제너레이터로 생성한 이터러블만 자기자신을 반환하는 well-formed이고,  
기본적으로 내장 iterator를 가지고 있는 "Array, String, NodeList..." 같은 애들은 well-formed가 아닌것 같은데...  

well-formed iterable이 가지는 장점이 있을까요 ?

```js
var iterG = valuesIter({ a: 1, b: 2 });
var arr = [ 1, 2 ];
var str = "abc";
var node = document.querySelectorAll("div");
var map = new Map([["a", 1],["b", 2]]);
var set = new Set([1, 2, 3]);

iterG[Symbol.iterator]() == iterG // true
arr[Symbol.iterator]() == arr // false
str[Symbol.iterator]() == str // false
node[Symbol.iterator]() == node // false
map[Symbol.iterator]() == map // false
set[Symbol.iterator]() == set // false
```

## A: 선생님 답변
* 일단, well-formed의 장점은 여기저기서 조합하기 좋다
* Array 역시도 well-formed가 맞음. 위의 테스트가 잘못되었음
```js
// 올바른 Test Case
var arr = [1,2,3];
arr[Symbol.iterator]() == arr // false

var arrIter = [1,2,3][Symbol.iterator]();
arrIter[Symbol.iterator]() == arrIter; // true
```
-> Array의 [Symbol.iterator] 메서드를 한번 실행시켜줘야 이터레이터가 된다 !   
-> 이터레이터가 된 후와 비교해야 올바른 테스트!

### `collIter()`함수의 코드가 이 원리와 같다
```js
const collIter = coll =>
  hasIter(coll) ? // [Symbol.iterator]를 가지고 있다면
    coll[Symbol.iterator]() : // 실행시켜줘야 -> 이터레이터가 된다
    valuesIter(coll); // 제너레이터는 호출하는 순간 실행 -> 이터레이터가 된다
```

### `Well-formed Iterable`가 유용한이유
>[Iterators that are iterable](
http://exploringjs.com/es6/ch_iteration.html#_iterators-that-are-iterable)  
Why is it useful if an iterator is also an iterable? for-of only works for iterables, not for iterators. Because Array iterators are iterable, ***you can continue an iteration in another loop***  

* Iterator이면서 Iterable인 객체를 `"잘정의된(well-formed) Iterable"`라고 부른다
* 제너레이터가 만들어주는 제너레이터객체는 `well-formed Iterable`  
* This is Why ES6 generators are usually much more convenient !

```js
//1. non well-formed

var fibonacci = {
  [Symbol.iterator]() {
    let [prev, curr] = [0, 1];
    let step = 0;
    const maxStep = 5;
    return {
      next() {
        [prev, curr] = [curr, prev + curr];
        return { value: curr, done: step++ >= maxStep };
      }
    };
  }
};

// Test -----

for(const v of fibonacci) {
  console.log(v);
  break;
} 
// 1

for(const v of fibonacci) {
  console.log(v);
} 
// 1 2 3 5 8 -> Restart iterator



//2. well-formed 

var fibonacciW = {
  prev: 0, curr: 1, step: 0, maxStep: 5,
  next() {
    [this.prev, this.curr] = [this.curr, this.prev + this.curr];
    return { value: this.curr, done: this.step++ >= this.maxStep };
  },
  [Symbol.iterator]() {
    console.log(this)
    return this;
  }
};

// Test -----

for(const v of fibonacciW) {
  console.log(v);
  break;
} 
// 1

for(const v of fibonacciW) {
  console.log(v);
} 
// 2 3 5 8 -> Continue with same iterator
```
```js
// 훈일님 노트 
var iter = (count = 0, length) => ({
  [Symbol.iterator]() {
    return {
      next() { return { value: count++, done: count > length }; }
    };
  }
});

var iterW = (count = 0, length) => ({
  [Symbol.iterator]() { 
    return this 
  },
  next() {
    return { value: count++, done: count > length };
  }
});


var iterObj = iter(0, 5);
var iterWObj = iterW(0, 5);

for (const v of iterObj) {
  console.log(v);
}

for (const v of iterWObj) {
  console.log(v);
}
```

## 결론  
* Array, String, Map, Set, NodeList는 `[Symbol.iterator]`를 내장메서드로 가지고 있기때문에 기본적으로 Iterable하다.  
* 하지만 well-formed Iterable로 동작하기 위해선 `[Symbol.iterator]()`를 한 번 실행시켜줘야한다

```js
var arr = [1,2,3]; //--> Iterable
var arrIt = arr[Symbol.iterator](); // well-formed Iterable

//1. Iterable
for(const v of arr) {
  console.log(v);
  break;
} // 1

for(const v of arr) {
  console.log(v);
} // 1 2 3 --> 다시 시작

//2. well-formed Iterable

for(const v of arrIt) {
  console.log(v);
  break;
} // 1 --> 순회한 위치를 기억

undefined
for(const v of arrIt) {
  console.log(v);
} // 2 3 -> Continue with Same iterator
```