## 프로그래밍?
문제들을 최대한 작게 쪼개서 해결하고 조합해 가는 과정
1. 함수 합성
2. 객체 합성

## Promise

### # 하스켈 표기법
모든곳에 타입을 써준다 (숭고함)
* "f1은 a를 받아 b를 반환하는 함수다" 라는 표기를 함  
`f1 :: Number a -> Number b`
* 하스켈은 인자를 하나밖에 넘기지 못한다 (curryng)
* 인자를 여러개를 한 번에 전달하는 방법? 튜플타입  
add(5, 5)이걸 -> add(5)(5)로 펴서 넣음

> 항상 비동기 코드를 염두하며 작성한다. 동기코드를 짤 때도 비동기가 될 상황을 염두함

## PostgreSQL의 노드
* async await를 풀어놓은 함수

## async ...await
* `await`
    * Promise객체를 풀어서 결과값을 반환해주는 키워드
    * then 메소드를 사용할 때보다 복잡한 비동기 데이터 흐름을 아주 쉽게 표현할 수 있다는 장점
    ```js
    b = Promise.resolve(10).then(r => {
        b = r;
        return b;
    });
    b = await Promise.resolve(10); // 훨씬 간략함
    ```
* 값이 평가되는 시점을 정확히 이해하는 개발자가 아니면, await는 "반드시 Promise를 리턴할거다" 라는 상황일 때가 사용하도록 권장한다
```js
b = await add10(a);
b = await sub10(a);
b = await sub10(a);

// 3번의 비동기
add10(a).then(sub10).then(sub10); 

b = await add10(a);
b = sub10(a);
b = sub10(a);

// 1번의 비동기, 이후 동기
add10(10).then(function(a) {
    sub10(sub10(a));
});
```
* async await는 비동기코드를 동기처럼 작동하는 마법? (사용하기 나름)
    * `f1(10)` -> 프로미스 리턴
    * `f1(10).then(console.log)` -> 결과값 리턴
    
* `log()`: 상황에따라 동기-비동기식으로 돌아가는 함수
    * 다형성
    * ~ 이거나, 아니거나 처리 가능한 성질
    * 함수형 프로그래밍에 중요한 특징
    ```js
    function log(a) {
      a instanceOf Promise ?
        a.then(console.log) : console.log(a);
    }
    ```

---

### 여담
>10년차까진 코드를 러프하게 봤다. 17년차인 지금은 코드의 공백 하나까지 세밀하게 본다 
* lisp코드: 모든게 리스트인 코드 - 공백까지 읽어야 해석되는 언어
* 자바스크립트로 함수형 프로그래밍을 하려면, 필히 자바스크립트를 lisp처럼 읽을 수 있어야 한다
* 함수형 프로그래밍을 안하더라도, 고급개발자가 되기 위해선 자바스크립트도 lisp처럼 읽을 수 있어야 한다
* 자바스크립트는 scheme(lisp)이라는 언어에서 많이 영향을 받음.
한 줄, 한 줄이 값으로 평가될 수 있는 성질
* lisp은 리스트 언어(문장이없는 언어), 자바스크립트는 문장도 있는 언어

---

>asp, 자바, 루비, iphon sdk등을 수많은 언어들을 사용 해왔지만, 기능들을 통채로 외워서 돌아갈 때까지 고치며 만들었다. 그런방식으로 개발해왔더니 9년차인 27까지 공부한 것중 남은게 없다. 

* 사용해야하는 큰 프레임워크를 익히는게 아니라, 부분 부분을 세세히 볼 줄아는 개발자들이 성공했다.
* 기술과 프레임웍은 계속 발전하고 바뀐다. 100% 장담하건데, 몇 년 후엔 리액트 없을 것이다
* 기능의 통채를 능숙하게 쓸 수 있는 법을 익히는게 아니라, 그걸 구성하고 있는 근육을 익혀야한다.

---

## 1. `go()`: 복잡한 문제를 한 번에 해결해보기
* 인수로 받은 함수가 동기/비동기 인지 상관없이 연산이 되도록 해주는 함수  
* Promise + 숫자" 가 NaN이 되지 않도록

```js
// 복잡 한번에

const add10 = a => new Promise(resolve => resolve(a + 10));
const sub10 = a => a - 10;
const add5 = a => a + 5;
const sub5 = a => new Promise(resolve => resolve(a - 5));

// f1: 비동기 + 동기함수를 호출
async function f1(a) {
  var b = a;
  b = await add10(b);
  b = sub10(b);
  b = add5(b);
  b = await sub5(b);
  return b;
}

// log: Promise의 다형성을 해결해주는 함수
function log(a) {
  a instanceof Promise ? 
    a.then(console.log) : console.log(a);
}

// go
function go (a, ...fs) {
  var b = a;
  var iter = fs[Symbol.iterator](); // 유사배열 -> iterable
  return function recur(b) {
    for(const f of iter) {
      b = f(b);
      if(b instanceof Promise) return b.then(recur);
    }
    return b;
  } (b);
}
```

>* oop는 세계관과 그에 관한 많은 패턴을 이해해야한다(큰 코드안의 조각들의 관계)  
>* 함수형은 이 코드가 어떤 결과를 낳을지만 중요(작은 코드조각의 평가)

---

## 2, 복잡한 문제를 작게 쪼개서 해결해보기
* 몸체가 작기 때문에 결과가 확실하다는 것을 확신할 수 있다 (정확하게 동작하는 함수들의 조합)
  * 함수형에선 테스트case를 먼저 만들고 아주 작은단위의 기능을 코드를 짠다(정확히 돌아가는지 확인 가능)
  * 고로 함수형 프로그래밍은 TDD가 필요없다. 가변적이지 않기 때문에
  * 각자의 역할이 정확히 나눠져 있기 때문에, 코드 수정이 쉽다
* 문장이 아닌 표현식으로 이루어져 있기때문에 해석할 필요가 없다


1. `then()`: Promise의 다형성을 해결하고
2. `callR()`: 인자로 받은 함수들을
3. `go()`: 실행 go!
```js


// then()
const then = f => a
// callR()
// go()
```



### 함수형 프로그래밍을 정의해보자면...?
>엄청난 논리구조로 코드를 짜놔도, 디버깅하면 결국은 i++, j가 잘못되있더라... 그래서 막연한 기대감으로 공부하기 시작한게 함수형 프로그래밍이다.
* 순수함수와 효과가 있는 함수를 잘 관리하는 프로그램
* 효과가있는 함수(파괴)를 위험하게 보고 격리하여 관리하려함
* 순수함수: 그 자체로 연산만 순수하게 함  
ex) `add10(a)`
* 효과가 있는함수: 어떤 공간을 파괴할 수 있는 일.   
ex) `console.log;`, `el.parentNode.removeChild(el);`

##### 효과있는 메서드. 없는 메서드 구분(김원)

* 객체지향: 효과가 있는 함수들을 연관되게 하는 프로그래밍 방법
* 함수형: 효과가 없는 합수들을 조합하는 프로그래밍 방법

---

쉬는시간

---

웹스톰 레인보우 브라켓 -> 함수형괄호에 최적화되어 있음

* 자바스크립트는 즉시평가
* 클로저는 기본적으로 지연평가 (1 && 8도 일종의 지연평가. 8을 1을 평가한 후 메모리에 저장)
    * 평가가 안된상태로 코드로 남아있다 (메모리에 쌓이지 않음)
    * 지연성을 가진 함수 (조건이 완벽해질 때까지 평가하지 않음? 왜? 아름답?)
* 메타프로그래밍이란? 자바스크립트의 규약들을 활용하여 지연성을 이용하는것

> 인트로 끝

---

# 1. 타입과 값

언어의 근간을 알아야 그 언어를 제대로 사용할 수 있다.
자바스크립트를 자바처럼 짜면 지옥...

(검색해보기) ADT: haskell처럼 자바스크립트를 프로그래밍하는방식. 컴파일단에서 최적화할 방법이 없어 매우 느려짐

## JSON 데이터 타입
(중요) 타입에 undefined가 없다. undefined라는 값을 전달할 수 없다

```js
JSON.stringify(null); // "null"
JSON.stringify(undefined); // undefined --> 동작된 것이 아님
JSON.parse(JSON.stringify(undefined)); // "null???
JSON.stringify(new Map()); // "{}" ---> 동작안됨
```

delete를 왜 안쓴다고? json할때 문제가 생기는거 같은데

---

# Iterable, Iterator
ES6에 새로 추가된 개념. Web API가 이들에 맞게 많은 프로토콜을 제공하기 때문에 제대로 이해하는 것이 중요하다.

Class를 쓰지 않는다 (= 사용자 정의 객체를 만들지 않는다)

Iterable이 뭐길래
다형성을 만들 때 가장 중요한 것은? 규약


* for...of를 실행할때, *이터레이터를 실행하는 코드*가 내부적으로 있다.  
* `.next()`를 실행하여 내부를 순회하는 것
* obj는 iterator가 없어서 의도적으로 심어줘야함

### 제너레이터
iterable을 리턴하는 함수. 값 하나만을 리턴하는 일반함수와는 다르다

```js
짜보기
```
* gen()을 단순히 호출하는 것만으로 실행되지 않는다 -> 지연성!!  
이것이 사용될 때 값이 평가되어진다   
이게 왜 중요한 걸까??  
내가 필요한 것을 제너레이터로 만들어봐야 그 감흥을 느낄 수 있다


* `.reverse()`의 문제?  
역행된 배열을 새로 생성한다. 이는 연산할 것이 많아지면 메모리에 엄청난 부하를 가져올 수 있다  
    ```js
    while로 reverse 리팩토링 해보기
    ```
    -> 지연성 생성. reverse는 한번에 값을 만들어 메모리에 저장하지만, 이는 실행하기전까지 메모리에 저장안해서 더 좋다

* `iterator[Symbol.iterator]();`를 가지고 있지 않으면 프로토콜을 다 지키지 않은 이터레이터다  
    * 바로 위 코드는 오케이지만 reverseIter, 그 위의 코드 obj 는 불완전하다. 아래코드는 심볼이터레이터가 iter2가 아닌 obj에 들어있음
    * 제너레이터로 만든 함수는 이를 모두 만족시킨다
    
* 이미 진행된 만큼의 이터레이터이다 (5:15).... 뭔소리지 ㅠ  
    * 이터레이터를 반복실행해도 무한루프에 빠지지 않도록 해줌  
    * 다시 새로시작하는게 아니라. 진행했던만큼을 기억하고 있어서, 그 지점에서 다시 시작함
    * 아주 중요한가치에요(5:19)

* users객체를 arr이 아닌 obj를 쓰면 좋은이유?(5:20)
    * 배열은 해당 아이디로 접근하기까지 앞에 있는 것들을 다 순회해야하지만
    * obj는 키 밸류쌍으로 되어 있어서 바로 접근가능하다
    * 그러면 arr을 Object.value로 객체만 뽑아와서 접근하면 되지 않을까?  
    아니. 그 크기만한 객체를 만든후에 뽑는 거기때문에 무겁다
    * 제너레이터를 사용하면, 똑같은 크기의 배열을 만들어내지 않고도 접근가능하다 -> 아주 가치있는 것
    > 이터러블을 얼마나 아느냐만큼 보는 시야의 범위가 달라진다

* for ...in문의 문제점
    * 루프를 돌면 객체의 프로퍼티뿐만아니라, 프로토타입까지 출력하는 문제   
    -> js 만들 때의 실수하고함  
    -> hasOwnProperty()로 해결 -> 코뿔소 보기
    * Class로 만든 객체는 for ...in문으로 돌려도 프로토타입이 걸려서 출력되지 않는다 (문제해결된거지? 하지만 클래스는 아직 모든 브라우저 호환이 안됨)  
    -> 이런면에서 Class를 단순히 Syntax Sugar라고만 말하면 안된다. 치명적인 문제를 해결한 것이기 때문에
    
---

쉬는 시간

---

# 유사배열

* 대표적인 유사배열은 제이쿼리 객체  
`$('div')` 로 찾아지는 객체가 유사배열이다 -> iterable이 아님
* underscore.js는 유사배열을 지원
* Web API는 for...of가 동작하는 이터러블 -> 유사배열을 사용하지 않는 방향으로 가는 추세라고 할 수 있다

---

* 결제에서 중요한 것은 클라이언트 값을 믿어서는 안된다는 것 !
* 클라이언트에서 얼마든지 값을 조정하여 날릴 수 있다
* 결론적을 서버에도 똑같은 DB구조가 있어 클라이언트 요청과 대비를 시켜 다르면 reject를 시켜야 한다

## undefined
* undefined는 자바스크립트 런타임에서 생성된 값이다
* DB에 저장할 수 없고, JSON으로 전달할 수도 없다  
-> 서버에서 날라온 값에 undefined가 있을리가 없다
* undefined를 선택지로 고려하지 않아도 되는 상황  
-> 하나의 구분자로 사용가능   
-> 인자로 undefined가 오지 않으면, for문을 다 돌았다고 확신할 수 있음 

## 영속성 혹은 종속성
* map, filter들을 이용하면 반환된 배열은 복사된 값이다 (메모리 낭비)
* 값복사가 많이 일어나지 않아 성능이슈를 제거해주자

## 화살표 함수

## Promise
값을 원시인 것, 객체인 것처럼  
프로미스인 것, 프로미스가 아닌 것으로 바라보는 관점이 다형성을 구현하기 좋다  
->병렬적으로 코딩하기 위해 가장 중요한 것이 프로미스이다

프로미스는 모나드(?)

---

# 3. 컬렉션 중심 프로그래밍
자바스크립트가 lisp로 프로그래밍하는 것과 비슷해진다  
-> 일련의 과정에 필요한 함수들을 한번에  

`<pre>`뭐임?

rxjs?

리액티브 프로그래밍?

---

숙제. 
깃헙코드의 모든 underscore.js함수 사용
제너레이터를 활용하여 하수 만들어보기











