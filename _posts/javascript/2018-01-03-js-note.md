# 자료구조
데이터의 구체적인 구현방법은 생략하고, 데이터의 추상적 형태와 그 데이터를 다루는 방법을 ADT(Abstract Data Type)라고 한다. 큐/스택/트리라는 구조가 많이 쓰인다.

## Queue 큐
* 순서대로 처리해야하는 작업. 선입선출 FIFO
* ex. 음원, 동영상버퍼링 처리 -> 네트워크가 느려질때 영상 다음장면을 버퍼(buffer)라는 곳에 임시로 저장해두고, 다운이 완료되면 순차적으로 보여준다.

## Stack 스택
* 나중에 집어넣은 데이터가 먼저 나옴. 후입후출 LIFO
* Ctrl + Z(되돌리기)와 같은 순서로 동작함
* 관계가 있는 여러 작업을 연달아 해야할때, 이전의 작업내용을 저장해두기위해 사용
* ex. 자바스크립트에서 일반적인 함수처리 방법

>큐와 스택의 차이점
큐는 선입선출 스택은 후입후출.

## 트리 Tree
* 데이터가 서로 계층구조를 가지고 연결된 상태일때 사용
* 잎노드(leap node): 자식노드가 없는 노드, 뿌리(root), 조상(ancestor), 자손(descendant)노드 등이 있음.
* ex. 알고리즘의 효율을 위해 트리구조를 사용함

-----

# 비동기 프로그래밍
특정기능이 로딩되는동안 다른작업을 할 수 있게 해줌.

## 타이머 API
* `setTimeout(() => {..}, 지연시간)` / `clearTimeout();`
지연시간이후 콜백함수를 1번 실행시킴
* `setInterval(() => {..}, 간격시간)` / ` clearInterval();`
interval(간격시간)마다 콜백함수를 계속 실행시킴

## timeout활용한 함수
1. debounce
이미 사용중인 아이디입니다. UI
타이핑중엔 동작안함. 마지막글자 입력 1초후 동작
ex. 이미 사용중인 아이디인지 실시간으로 확인할 때
1초이내에 여러번 실행한 동작을 하나로 묶어 생각.
마지막 동작 이후에 함수실행

2. throttled
일정시간 전까지 실행을 막아주는 함수
최소 100ms 간격동안은 함수실행안함
동작이 여러번 있다고 하더라도 상관않고, 정해진 시간이후에 함수를 실행함
* ex. 구글동기화 -> 타이핑할때 저장중...이라고뜨는거 구라임. 타이핑 손떼야 저장함
그림을 그리는 서비스이다. 일정시간마다 서버에 저장시켜줘야한다. 하지만 매초 모든변경사항을 저장시키면 과부하가 걸릴 수 있기때문에, 일정시간마다만
* 검색창 자동완성 단어단위로 ㄱ ㄴ ㄹ 단위아니라

## input이벤트
: input 내용이 변경될때마다 이벤트 발생(mousemove와 비슷)
* input이 실행되는 순간 시작되면 되는 함수이므로, e 이벤트객체 받을 필요 없음
* mousemove같은 마우스위치를 받아와야하는 이벤트들은 e 이벤트 객체가 필요
* keydown이벤트는 어떤 keycode입력했는지 받아오는 e 이벤트객체 필요함

## 타이머 사용시 주의 -> 지연시간의 미묘한 차이
실제 지연시간과 매번 약간의 차이가 존재
```js
const start = new Date();

setTimeout(() => {
  console.log(new Date() - start);
}, 100); //100, 101, 104...
```
-> 100초뒤에 실행하는 함수이므로, console에 100이 나올걸 예상했지만 104, 101...등 매번 다른초가 나옴

>자바스크립트의 코드 실행과정때문에 생기는 이슈임.

-----

# 브라우저 Javascript 코드 실행 과정

## 콜스택 Call Stack
서로가 서로를 호출하는 함수들간의 관계에 따라 호출 스택에 저장되는 순서가 다르고 실행은 후입선출(LIFO)방식으로 진행된다
>에러검출시 버그를 잡기위해 중요함!

>일반함수는 호출형태에 따라, 화살표함수는 정의된 형태에 따라 this가 달라진다

## 작업큐 Task Queue

Task Queue -> Call Stack으로 큐가 이동되는 찰나(잠시 호출 스택이 비워질때) 화면이 다시 그려진다.

```js
setTimeout(() => {
  console.log('hello');
}, 0); // 작업 큐에 콜백이 추가됨

console.log('world');
//'world' 'hello'
```
setTimeout함수는 바로 호출스택에 들어가지않고 무조건 Task Queue를 거친다
console.log함수는 바로 호출스택에 들어가 실행됨
따라서 setTimeout 지연시간을 0으로 했어도 console보다 늦게 출력된다

-----

# 비동기 프로그래밍
어떤 일이 완료되기를 기다리지 않고 다음 코드를 실행해 나가는 프로그래밍 방식
* 통신, 계산같이 오래걸리는 작업을 브라우저에 위임
* 콜스택을 효율적으로 쓰는 프로그램방식. 성능, 속도good
* 코드와 실제 실행되는 것의 순서가 뒤죽박죽 됨 -> 가독성 bad -> 디버깅어려움

* 콜백헬 데이터 흐름이 조금만 복잡해져도 코드가 복잡해지는 문제

-----
# Promise
* '언젠가 끝나는 작업'의 결과값을 담는 통과 같은 객체
* 콜백의 문제를 해결하기 위한 라이브러리
* 표준화되어, ES2015에 JavaScript 언어 자체에 포함

*  then 메소드를 통해 콜백을 등록
* resolve에 인자로 준 값이 곧 Promise 객체의 궁극적인 결과값

* then에서 Promise를 리턴해주면 Promise자체가 아닌 안에 있는 value를 다음 then의 인자로 전달해준다


















